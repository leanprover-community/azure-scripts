name: Monitor Self-Hosted Runners

on:
  # push: # uncomment for testing if on a branch in the azure_scripts repo
  schedule:
    - cron: '7/15 * * * *' # every 15 minutes but at :07, :22, :37, :52 to try to make it less likely that github drops the job
    - cron: '0 9 * * 1' # weekly report every Monday at 9 AM UTC
  workflow_dispatch:
    inputs:
      send_weekly_report:
        description: 'Send a weekly report to Zulip'
        required: false
        default: false
        type: boolean

env:
  ZULIP_SERVER: "https://leanprover.zulipchat.com"
  ZULIP_CHANNEL: "CI admins"
  STATE_FILE: "runner-state.json"
  STATS_FILE: "runner-stats.json"
  CACHE_KEY: ${{ github.ref == 'refs/heads/master' && 'runner-monitor-state-v4' || 'runner-monitor-state-testing' }}
  STATS_CACHE_KEY: ${{ github.ref == 'refs/heads/master' && 'runner-monitor-stats-v4' || 'runner-monitor-stats-testing' }}
  DRY_RUN: ${{ github.ref != 'refs/heads/master' }}

jobs:
  monitor-runners:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf # v2.2.1
        id: app-token
        with:
          app-id: ${{ secrets.LEANPROVER_COMMUNITY_RUNNERS_APP_ID }}
          private-key: ${{ secrets.LEANPROVER_COMMUNITY_RUNNERS_PRIVATE_KEY }}

      - name: Restore previous state
        id: cache-restore
        uses: actions/cache/restore@0400d5f644dc74513175e3cd8d07132dd4860809 # v4.2.4
        with:
          path: ${{ env.STATE_FILE }}
          key: ${{ env.CACHE_KEY }}-${{ github.run_id }}
          restore-keys: ${{ env.CACHE_KEY }}

      - name: Restore previous stats
        id: stats-cache-restore
        uses: actions/cache/restore@0400d5f644dc74513175e3cd8d07132dd4860809 # v4.2.4
        with:
          path: ${{ env.STATS_FILE }}
          key: ${{ env.STATS_CACHE_KEY }}-${{ github.run_id }}
          restore-keys: ${{ env.STATS_CACHE_KEY }}

      - name: Create empty state
        if: steps.cache-restore.outputs.cache-hit == ''
        run: |
          echo "No previous state file found, creating empty state"
          echo '{"last_run": "", "runners": {}}' > "${{ env.STATE_FILE }}"

      - name: Create empty stats
        if: steps.stats-cache-restore.outputs.cache-hit == ''
        run: |
          echo "No previous stats file found, creating empty stats"
          echo '{"runners": {}, "last_cleanup": ""}' > "${{ env.STATS_FILE }}"

      - name: Check self-hosted runners
        id: check-runners
        run: |
          python3 -m monitor_runners.workflow check-runners \
            --token "${{ steps.app-token.outputs.token }}" \
            --org "${{ github.repository_owner }}" \
            --state-file "${{ env.STATE_FILE }}" \
            --stats-file "${{ env.STATS_FILE }}" \
            --response-file "runners_response.json" \
            --schedule "${{ github.event.schedule || '' }}" \
            --send-weekly-report "${{ toJSON(inputs.send_weekly_report) }}" \
            --github-output "$GITHUB_OUTPUT"

      - name: Find out if there are active bors batches
        id: bors_active
        run: |
          response=$(curl -sf "https://mathlib-bors-ca18eefec4cb.herokuapp.com/api/active-batches") || { echo "result=true" >> "$GITHUB_OUTPUT"; exit 0; }
          length=$(echo "$response" | jq '.batch_ids | length')
          echo "result=$([ "$length" -gt 0 ] && echo true || echo false)" >> "$GITHUB_OUTPUT"

      - name: Manage runner labels based on bors status
        id: manage-labels
        if: steps.check-runners.outputs.api_ok == 'true'
        run: |
          dry_run="${{ env.DRY_RUN }}"
          if [ "$dry_run" = "true" ]; then
            echo "DRY RUN: skipping runner label mutations (non-master branch)"
          fi

          bors_active="${{ steps.bors_active.outputs.result }}"
          echo "Bors active: $bors_active"

          # Load the runners response
          response=$(cat runners_response.json)

          # Initialize outputs
          label_summary=""
          label_errors=""

          # Helper function to add a label to a runner
          add_label() {
            local runner_id=$1
            local runner_name=$2
            local label=$3

            if [ "$dry_run" = "true" ]; then
              label_summary+="üß™ Would add \`$label\` label to runner \`$runner_name\`\n"
              return 0
            fi

            local update_response=$(curl -s -X POST \
              -H "Authorization: token ${{ steps.app-token.outputs.token }}" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/orgs/${{ github.repository_owner }}/actions/runners/$runner_id/labels" \
              -d "{\"labels\":[\"$label\"]}")

            if echo "$update_response" | jq -e '.labels' > /dev/null 2>&1; then
              label_summary+="üè∑Ô∏è Added \`$label\` label to runner \`$runner_name\`\n"
              return 0
            else
              echo "ERROR: Failed to add label $label to runner $runner_name"
              echo "Response: $update_response"
              label_errors+="‚ùå Failed to add \`$label\` label to runner \`$runner_name\`\n"
              return 1
            fi
          }

          # Helper function to remove a label from a runner
          remove_label() {
            local runner_id=$1
            local runner_name=$2
            local label=$3

            if [ "$dry_run" = "true" ]; then
              label_summary+="üß™ Would remove \`$label\` label from runner \`$runner_name\`\n"
              return 0
            fi

            local update_response=$(curl -s -X DELETE \
              -H "Authorization: token ${{ steps.app-token.outputs.token }}" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/orgs/${{ github.repository_owner }}/actions/runners/$runner_id/labels/$label")

            # DELETE returns 204 No Content on success, or 404/422 on error
            if [ $? -eq 0 ]; then
              label_summary+="üè∑Ô∏è Removed \`$label\` label from runner \`$runner_name\`\n"
              return 0
            else
              echo "ERROR: Failed to remove label $label from runner $runner_name"
              echo "Response: $update_response"
              label_errors+="‚ùå Failed to remove \`$label\` label from runner \`$runner_name\`\n"
              return 1
            fi
          }

          cleanup_label="cleanup-soon"

          # Extract runner data (id, name, custom labels), skipping cleanup-soon and ephemeral runners
          echo "Extracting runner data (non-ephemeral)..."
          runner_data=$(echo "$response" | jq -r --arg cleanup_label "$cleanup_label" '
            .runners[]
            | select([.labels[] | select(.type == "custom") | .name] | contains([$cleanup_label]) | not)
            | select([.labels[]? | .name] | index("ephemeral") | not)
            | "\(.id)|\(.name)|\([.labels[] | select(.type == "custom") | .name] | join(","))"
          ')

          if [ -z "$runner_data" ]; then
            echo "ERROR: No non-ephemeral runners found"
            label_errors+="‚ùå **Label Management Error:** No non-ephemeral runners found in organization\n\n"
          else
            # Ensure all runners have 'bors' label
            echo "Checking if all runners have 'bors' label..."
            while IFS='|' read -r runner_id runner_name labels; do
              # Check if 'bors' is present
              if [[ ",$labels," != *",bors,"* ]]; then
                echo "Adding 'bors' label to runner: $runner_name"
                add_label "$runner_id" "$runner_name" "bors"
              fi
            done <<< "$runner_data"

            # Now manage 'pr' label based on bors status
            if [ "$bors_active" = "true" ]; then
              echo "Managing 'pr' labels (bors active - one runner should NOT have 'pr')..."

              # Check if there's already a runner without 'pr'
              runner_without_pr=$(echo "$response" | jq -r --arg cleanup_label "$cleanup_label" '
                .runners[]
                | select(
                  ([.labels[] | select(.type == "custom") | .name] | contains([$cleanup_label]) | not)
                  and
                  ([.labels[]? | .name] | index("ephemeral") | not)
                  and
                  ([.labels[] | select(.type == "custom") | .name] | contains(["pr"]) | not)
                )
                | .name
              ' | head -n 1)

              if [ -n "$runner_without_pr" ]; then
                echo "Runner '$runner_without_pr' already lacks 'pr' label - no changes needed"
                label_summary+="‚úÖ Runner \`$runner_without_pr\` already lacks \`pr\` label (no changes needed)\n"
              else
                echo "All runners have 'pr' - selecting one to remove it from"

                # Find an idle runner first, fall back to any online runner
                selected_runner=$(echo "$response" | jq -r --arg cleanup_label "$cleanup_label" '
                  .runners[]
                  | select(.status == "online" and .busy == false)
                  | select([.labels[] | select(.type == "custom") | .name] | contains([$cleanup_label]) | not)
                  | select([.labels[]? | .name] | index("ephemeral") | not)
                  | "\(.id)|\(.name)"
                ' | head -n 1)

                if [ -z "$selected_runner" ]; then
                  echo "No idle runner found, selecting any online runner"
                  selected_runner=$(echo "$response" | jq -r --arg cleanup_label "$cleanup_label" '
                    .runners[]
                    | select(.status == "online")
                    | select([.labels[] | select(.type == "custom") | .name] | contains([$cleanup_label]) | not)
                    | select([.labels[]? | .name] | index("ephemeral") | not)
                    | "\(.id)|\(.name)"
                  ' | head -n 1)
                fi

                if [ -z "$selected_runner" ]; then
                  echo "ERROR: No online runners found"
                  label_errors+="‚ùå **Label Management Error:** No online runners available to remove \`pr\` label from\n\n"
                else
                  IFS='|' read -r runner_id runner_name <<< "$selected_runner"
                  echo "Removing 'pr' label from runner: $runner_name"
                  remove_label "$runner_id" "$runner_name" "pr"
                fi
              fi

            else
              echo "Managing 'pr' labels (bors inactive - all runners should have 'pr')..."

              all_have_pr=true
              while IFS='|' read -r runner_id runner_name labels; do
                # Check if 'pr' is present
                if [[ ",$labels," != *",pr,"* ]]; then
                  all_have_pr=false
                  echo "Adding 'pr' label to runner: $runner_name"
                  add_label "$runner_id" "$runner_name" "pr"
                fi
              done <<< "$runner_data"

              if [ "$all_have_pr" = true ]; then
                echo "All runners already have 'pr' label"
                label_summary+="‚úÖ All runners already have \`pr\` label\n"
              fi
            fi
          fi

          # Save summary to output (for logging)
          echo "label_summary<<EOF" >> $GITHUB_OUTPUT
          echo -e "$label_summary" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Only set error output if there are actual errors
          if [ -n "$label_errors" ]; then
            echo "label_errors<<EOF" >> $GITHUB_OUTPUT
            echo -e "$label_errors" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "has_label_errors=true" >> $GITHUB_OUTPUT
          else
            echo "label_errors=" >> $GITHUB_OUTPUT
            echo "has_label_errors=false" >> $GITHUB_OUTPUT
          fi

          # Clean up
          rm -f runners_response.json

      - name: Generate stats report
        id: weekly-stats
        run: |
          python3 -m monitor_runners.workflow weekly-report \
            --stats-file "${{ env.STATS_FILE }}" \
            --github-output "$GITHUB_OUTPUT"

      - name: Send status message on Zulip
        if: steps.check-runners.outputs.should_notify == 'true'
        id: zulip-status
        run: |
          dry_run="${{ env.DRY_RUN }}"
          if [ "$dry_run" = "true" ]; then
            echo "DRY RUN: would send Zulip status message"
            echo "message_id=dry-run" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Ensure that the bot is subscribed to the env.ZULIP_CHANNEL
          # Otherwise it will not have permission to edit its own messages!
          zulip_url="${{ env.ZULIP_SERVER }}"
          zulip_email="${{ secrets.ZULIP_MONITOR_RUNNERS_BOT_EMAIL }}"
          zulip_key="${{ secrets.ZULIP_MONITOR_RUNNERS_API_KEY }}"
          message_id="${{ steps.check-runners.outputs.last_message_id }}"

          content_file=$(mktemp)
          cat << 'EOF' > "$content_file"
          ${{ steps.check-runners.outputs.message }}
          EOF

          if [ "${{ steps.check-runners.outputs.should_edit }}" = "true" ]; then
            echo "Editing existing Zulip message: $message_id"
            response=$(curl -s -X PATCH \
              -u "$zulip_email:$zulip_key" \
              "$zulip_url/api/v1/messages/$message_id" \
              --data-urlencode "content@$content_file")
          else
            echo "Sending new Zulip message"
            response=$(curl -s -X POST \
              -u "$zulip_email:$zulip_key" \
              "$zulip_url/api/v1/messages" \
              --data-urlencode "type=stream" \
              --data-urlencode "to=${{ env.ZULIP_CHANNEL }}" \
              --data-urlencode "topic=Runner Status" \
              --data-urlencode "content@$content_file")
            message_id=$(echo "$response" | jq -r '.id // empty')
          fi

          if ! echo "$response" | jq -e '.result == "success"' > /dev/null; then
            echo "ERROR: Zulip API request failed"
            echo "$response"
            exit 1
          fi

          if [ -z "$message_id" ]; then
            echo "ERROR: Missing Zulip message id"
            echo "$response"
            exit 1
          fi

          echo "message_id=$message_id" >> "$GITHUB_OUTPUT"
          rm -f "$content_file"

      - name: Update status notification state
        if: steps.check-runners.outputs.should_notify == 'true'
        run: |
          if [ "${{ env.DRY_RUN }}" = "true" ]; then
            echo "DRY RUN: would update status notification state"
            exit 0
          fi

          current_time=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          offline_set='${{ steps.check-runners.outputs.offline_set }}'
          message_id="${{ steps.zulip-status.outputs.message_id }}"

          state=$(cat "${{ env.STATE_FILE }}")
          updated_state=$(echo "$state" | jq \
            --arg time "$current_time" \
            --arg message_id "$message_id" \
            --argjson offline_set "$offline_set" \
            '
            .last_notification = (.last_notification // {}) |
            .last_notification.offline_set = $offline_set |
            .last_notification.message_id = $message_id |
            .last_notification.updated_at = $time
            ')

          echo "$updated_state" > "${{ env.STATE_FILE }}"

      - name: Send label management notification on Zulip
        if: steps.manage-labels.outputs.has_label_errors == 'true' && github.ref == 'refs/heads/master'
        uses: zulip/github-actions-zulip/send-message@e4c8f27c732ba9bd98ac6be0583096dea82feea5 # v1.0.2
        with:
          api-key: ${{ secrets.ZULIP_MONITOR_RUNNERS_API_KEY }}
          email: ${{ secrets.ZULIP_MONITOR_RUNNERS_BOT_EMAIL }}
          organization-url: ${{ env.ZULIP_SERVER }}
          to: ${{ env.ZULIP_CHANNEL }}
          type: 'stream'
          topic: 'Runner Status'
          content: |
            ${{ steps.manage-labels.outputs.label_errors }}

      - name: Send processing error notification on Zulip
        if: steps.check-runners.outputs.has_processing_errors == 'true' && github.ref == 'refs/heads/master'
        uses: zulip/github-actions-zulip/send-message@e4c8f27c732ba9bd98ac6be0583096dea82feea5 # v1.0.2
        with:
          api-key: ${{ secrets.ZULIP_MONITOR_RUNNERS_API_KEY }}
          email: ${{ secrets.ZULIP_MONITOR_RUNNERS_BOT_EMAIL }}
          organization-url: ${{ env.ZULIP_SERVER }}
          to: ${{ env.ZULIP_CHANNEL }}
          type: 'stream'
          topic: 'Runner Status'
          content: |
            ${{ steps.check-runners.outputs.processing_errors }}

      - name: Send weekly report on Zulip
        if: steps.check-runners.outputs.is_weekly_report == 'true' && github.ref == 'refs/heads/master'
        uses: zulip/github-actions-zulip/send-message@e4c8f27c732ba9bd98ac6be0583096dea82feea5 # v1.0.2
        with:
          api-key: ${{ secrets.ZULIP_MONITOR_RUNNERS_API_KEY }}
          email: ${{ secrets.ZULIP_MONITOR_RUNNERS_BOT_EMAIL }}
          organization-url: ${{ env.ZULIP_SERVER }}
          to: ${{ env.ZULIP_CHANNEL }}
          type: 'stream'
          topic: 'Weekly Runner Report'
          content: |
            ${{ steps.weekly-stats.outputs.weekly_message }}

      - name: Save state to cache
        if: always() && (github.event_name != 'workflow_dispatch' || github.ref != 'refs/heads/master') # On manual run of test branches it's okay to upload: the cache key won't collide
        uses: actions/cache/save@0400d5f644dc74513175e3cd8d07132dd4860809 # v4.2.4
        with:
          path: ${{ env.STATE_FILE }}
          key: ${{ env.CACHE_KEY }}-${{ github.run_id }}

      - name: Save stats to cache
        if: always() && (github.event_name != 'workflow_dispatch' || github.ref != 'refs/heads/master')  # On manual run of test branches it's okay to upload: the cache key won't collide
        uses: actions/cache/save@0400d5f644dc74513175e3cd8d07132dd4860809 # v4.2.4
        with:
          path: ${{ env.STATS_FILE }}
          key: ${{ env.STATS_CACHE_KEY }}-${{ github.run_id }}

      - name: upload files as artifact
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: monitor_runners_artifact
          path: |
            ${{ env.STATE_FILE }}
            ${{ env.STATS_FILE }}

      - name: Log summary
        run: |
          echo "=== Runner Monitor Summary ==="
          echo "::group::State file contents:"
          cat "${{ env.STATE_FILE }}" | jq .
          echo "::endgroup::"

          echo "::group::Stats file contents:"
          cat "${{ env.STATS_FILE }}" | jq .
          echo "::endgroup::"

          echo ""
          echo "=== Statistics Summary ==="
          runner_count=$(cat "${{ env.STATS_FILE }}" | jq '.runners | keys | length')
          echo "Runners tracked: $runner_count"
          data_points=$(cat "${{ env.STATS_FILE }}" | jq '[.runners[].history[]] | length')
          echo "Total data points: $data_points"

          echo ""
          echo "=== Label Management Summary ==="
          echo "Bors active: ${{ steps.bors_active.outputs.result }}"
          cat << 'EOF'
          ${{ steps.manage-labels.outputs.label_summary }}
          EOF
          if [ "${{ steps.manage-labels.outputs.has_label_errors }}" = "true" ]; then
            echo "‚ö†Ô∏è Label management errors occurred (see Zulip notification)"
          fi

          echo ""
          echo "::group::=== 7-Day Statistics Report ==="
          cat << 'EOF'
          ${{ steps.weekly-stats.outputs.weekly_message }}
          EOF
          echo "::endgroup::"

          if [ "${{ steps.check-runners.outputs.should_notify }}" = "true" ]; then
            echo ""
            echo "üì¢ Status notifications sent to Zulip"
          else
            echo ""
            echo "‚úÖ No status notifications needed - all runners stable"
          fi

          if [ "${{ steps.check-runners.outputs.is_weekly_report }}" = "true" ]; then
            echo "üìä Weekly report sent to Zulip"
          else
            echo "üìä Weekly report generated but not sent (not scheduled weekly run)"
          fi

  workflow-keepalive:
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    permissions:
      actions: write
    steps:
      - uses: liskin/gh-workflow-keepalive@f72ff1a1336129f29bf0166c0fd0ca6cf1bcb38c # v1.2.1
